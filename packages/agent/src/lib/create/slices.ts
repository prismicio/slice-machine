import { writeFile, access, mkdir } from "node:fs/promises";
import { join } from "node:path";
import chalk from "chalk";
import type { NextEnvironment } from "../detectEnvironment";
import type { SharedSlice } from "@prismicio/types-internal/lib/customtypes";

function pascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
    .replace(/^[a-z]/, (chr) => chr.toUpperCase());
}

export async function createSliceComponents(
  cwd: string,
  env: NextEnvironment,
  slices: SharedSlice[],
  verbose: boolean,
): Promise<{ created: number; skipped: number }> {
  let created = 0;
  let skipped = 0;

  for (const slice of slices) {
    const wasCreated = await createSliceComponent(cwd, env, slice, verbose);
    if (wasCreated) {
      created++;
    } else {
      skipped++;
    }
  }

  return { created, skipped };
}

async function createSliceComponent(
  cwd: string,
  env: NextEnvironment,
  slice: SharedSlice,
  verbose: boolean,
): Promise<boolean> {
  const basePath = env.hasSrcDirectory ? "src" : ".";
  const sliceName = pascalCase(slice.name);
  const extension = env.isTypeScript ? "tsx" : "jsx";
  const sliceDir = join(cwd, basePath, "slices", sliceName);
  const filename = join(sliceDir, `index.${extension}`);

  // Check if file already exists
  try {
    await access(filename);
    if (verbose) {
      console.log(
        chalk.gray(
          `‚è≠Ô∏è  Skipped ${basePath}/slices/${sliceName}/index.${extension} (exists)`,
        ),
      );
    }
    return false;
  } catch {
    // File doesn't exist, create it
  }

  // Create slice directory
  await mkdir(sliceDir, { recursive: true });

  const contents = generateSliceComponent(slice, env.isTypeScript);

  await writeFile(filename, contents, "utf8");

  if (verbose) {
    console.log(
      chalk.green(
        `‚úÖ Created ${basePath}/slices/${sliceName}/index.${extension}`,
      ),
    );
  }

  return true;
}

function generateSliceComponent(
  slice: SharedSlice,
  isTypeScript: boolean,
): string {
  const pascalName = pascalCase(slice.name);

  if (isTypeScript) {
    return `import { type FC } from "react";
import { type Content } from "@prismicio/client";
import { type SliceComponentProps } from "@prismicio/react";

/**
 * Props for \`${pascalName}\`.
 */
export type ${pascalName}Props = SliceComponentProps<Content.${pascalName}Slice>;

/**
 * Component for "${slice.name}" Slices.
 */
const ${pascalName}: FC<${pascalName}Props> = ({ slice }) => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      Placeholder component for ${slice.id} (variation: {slice.variation}) Slices
      <br />
      <strong>You can edit this slice directly in your code editor.</strong>
      {/**
       * üí° Use the Prismic MCP server with your code editor
       * üìö Docs: https://prismic.io/docs/ai#code-with-prismics-mcp-server
       */}
    </section>
  );
};

export default ${pascalName};
`;
  } else {
    return `/**
 * @typedef {import("@prismicio/client").Content.${pascalName}Slice} ${pascalName}Slice
 * @typedef {import("@prismicio/react").SliceComponentProps<${pascalName}Slice>} ${pascalName}Props
 * @type {import("react").FC<${pascalName}Props>}
 */
const ${pascalName} = ({ slice }) => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      Placeholder component for ${slice.id} (variation: {slice.variation}) Slices
      <br />
      <strong>You can edit this slice directly in your code editor.</strong>
      {/**
       * üí° Use the Prismic MCP server with your code editor
       * üìö Docs: https://prismic.io/docs/ai#code-with-prismics-mcp-server
       */}
    </section>
  );
};

export default ${pascalName};
`;
  }
}

export async function updateSliceLibraryIndex(
  cwd: string,
  env: NextEnvironment,
  slices: SharedSlice[],
  verbose: boolean,
): Promise<void> {
  const basePath = env.hasSrcDirectory ? "src" : ".";
  const slicesDir = join(cwd, basePath, "slices");
  const extension = env.isTypeScript ? "ts" : "js";
  const indexPath = join(slicesDir, `index.${extension}`);

  // Ensure slices directory exists
  await mkdir(slicesDir, { recursive: true });

  const imports: string[] = [];
  const componentEntries: string[] = [];

  for (const slice of slices) {
    const sliceName = pascalCase(slice.name);
    imports.push(`import ${sliceName} from "./${sliceName}";`);
    componentEntries.push(`  ${slice.id}: ${sliceName},`);
  }

  let contents: string;

  if (env.isTypeScript) {
    contents = `// Code generated by Slice Machine. DO NOT EDIT.

${imports.join("\n")}

export const components = {
${componentEntries.join("\n")}
};
`;
  } else {
    contents = `// Code generated by Slice Machine. DO NOT EDIT.

${imports.join("\n")}

export const components = {
${componentEntries.join("\n")}
};
`;
  }

  await writeFile(indexPath, contents, "utf8");

  if (verbose) {
    console.log(
      chalk.green(`‚úÖ Updated ${basePath}/slices/index.${extension}`),
    );
  }
}
