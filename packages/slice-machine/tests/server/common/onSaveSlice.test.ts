import MockedBackendEnv from "../../__mocks__/backendEnvironment";
import { MockLibraryInfo } from "../../__mocks__/libraryState";
import onSaveSlice from "../../../server/src/api/common/hooks/onSaveSlice";
import { BackendEnvironment } from "@lib/models/common/Environment";
import { Models } from "@slicemachine/core";
import { vol } from "memfs";

jest.mock(`fs`, () => {
  const { vol } = jest.requireActual("memfs");
  return vol;
});

jest.mock(`@slicemachine/core/build/libraries`, () => {
  const actualCore = jest.requireActual("@slicemachine/core/build/libraries");
  return {
    ...actualCore,
    libraries: (cwd: string, libs: string[]) =>
      libs.map((lib) => MockLibraryInfo(lib)),
  };
});

jest.mock("../../../server/src/api/common/LibrariesState", () => {
  return {
    generateState: jest.fn(),
  };
});

const expectedIndexFile = `// Code generated by Slice Machine. DO NOT EDIT.

import SliceName from './SliceName';

export {
\tSliceName,
};

export const components = {
\tsliceId: SliceName,
};
`;

const expectedSvelteIndexFile = `// Code generated by Slice Machine. DO NOT EDIT.

const Slices = {}
export default Slices

import SliceName from './SliceName/index.svelte'
Slices.SliceName = SliceName
`;

describe("onSaveSlice", () => {
  it("should generate index.js file", async () => {
    const env: BackendEnvironment = {
      ...MockedBackendEnv,
      framework: Models.Frameworks.next,
    };

    await onSaveSlice(env);

    const index = vol.readFileSync("/test/slice1/index.js", "utf8");
    expect(index).toEqual(expectedIndexFile);
  });

  it("should generate svelte index", async () => {
    const env: BackendEnvironment = {
      ...MockedBackendEnv,
      framework: Models.Frameworks.svelte,
    };

    await onSaveSlice(env);

    const index = vol.readFileSync("/test/slice1/index.js", "utf8");
    expect(index).toEqual(expectedSvelteIndexFile);
  });
});
